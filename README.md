# 2211


# 178D  Redistribution  diff 875

解答遷移 AC

計 1時間 over

備考

➀　思考

メモ化再帰で解けるし、ちょうどいいからエラストテネスみたいにこの問題でお勉強しよう! → 再帰関数の変数 や return の仕組みが意味わからん過ぎて時間が死ぬほど経過　→　諦めて素直にdpっぽい感じのコード書いたら通って意味不明

③ 解法

f(S) は f(3) ～ f(S-3) を呼び、答えがそれらの和 +1 になる。これを実装するには f(S,ans) の返り値を ans として、ans に for ループで回した f(3,1) ～ f(S-3,1) を足し合わせればよい。


# dfs 再帰勉強編

・ Q1 箱の中

bfsすれば dist[X] が答え。

dfs する場合であっても結局距離をリストで管理しなければいけないので bfs でいい。

・ Q5 子孫の数

dfs は帰りがけで処理できるメリットあり


# 1102

# 204C Tour  diff 629  再

解答遷移 RE AC

計 11:21 + 05:00

備考

➀　思考

始点を変えて dfsしてたどり着ける点の数をカウントしていけばよいと考えた。始点を変える際に、訪れた都市を管理するリストの初期化が必要。




# 1104

# 計算量 についての再確認

➀ 係数は無視 O(2N) → O(N)

![image](https://user-images.githubusercontent.com/109026838/199887431-66876afe-00cc-42e0-aec7-fb89f56235e6.png)

![image](https://user-images.githubusercontent.com/109026838/199887444-d18e30dd-a1a4-4ea6-adcb-c80ffb30a3ed.png)

そもそもオーダーは単なる見積もりなのである。


➁ for ループ

for i in range(N):
  
  for j in range(N):
    
    if j>100:
    
      break
    
    O(1)

のような処理を考えると計算量は O(N^2) である。なぜなら計算量は最悪の場合を考えるので、break が起こらなかった場合 N^2 回 O(1)の計算が発生し、O(N^2)となる。break や continue の解釈はこういうことであり、for ループ の i を進めること自体に O(1)かかっているわけではない。実際 break された結果 100回 O(1) が行われたなら、実際の計算量はO(100)である。つまり、ただポインタを進めるだけのループ処理ならば 計算量は 0 になるわけである。



# 183C Travel  diff 335　　再
 
解答遷移 AC

計 07:18

備考

➀　思考

 itertools.permutation で順番を全探索して時間を比較するだけ。(0,) + 順番 + (0,) で都市0 からスタートして 都市0 に戻る経路をタプルで表現すればよいと考えた。

➁ 初見 dfs 

dfsした場合でも 7! 回再帰するだけなので十分高速


# 226C Martial artist   diff 539  再

解答遷移 AC

備考

➀ 思考

覚えるべき技を根としたグラフを dfs,bfs して時間を累積していくだけ。先に覚えるべき子の処理を完了してから帰りがけで時間を累積する処理と、行きがけで先に累積する処理に違いはないので問題文を素直に受け取らず後者で実装した。


# 211D Number of Shortest paths   diff 755   再

解答遷移 AC

備考

➀ 思考

bfsで各頂点の最短距離を調べあげ、再びbfsして経路数をdp的に数え上げる処理を考えた。

➁ 解法

bfsで各頂点の最短距離を求めながら、調べている経路が最短経路であるならばdp的に経路数を数え上げる処理を行えば 一回のbfsで済ませられる。

③ dfs 計算量

bfsでは、経路数の数え上げ処理で同じ頂点を何度も調べることがあるものの、同一辺は高々1回しか探索されない。したがって計算量は O(M)になる。

一方、dfsでは同じ経路であっても何度も訪れなければいけない。よって明らかにbfsよりも計算量が多く、この問題を解答するアルゴリズムとして適していると言えない


# 270C Simple path  diff 625   本番後初

解答遷移 AC

計 13:14

備考

➀　思考

Xを根にしたグラフを作成し、Yまでの経路を出力すればよいと考えた。これは、dfs or bfs で X から探索を初めて、次の頂点の親が今の頂点であることを連結リスト的に記録することで実装できると考えた。探索後に Y から親を que にappendleft していけば、求めるべき順番が得られる。計算量はdfs,bfsどちらでも O(N+M) 


# 275D Yet Another Recursive Function  diff 606

解答遷移 AC

計 02:49

備考

➀ 思考

メモ化再帰するだけ

➁　計算量

O(引数の種類) になる。引数はN//(2^i* 3^j) と表現できることに注目すると、これは1以上だから、i <= log2N ,j<=log3N となる。したがって種類は i* j 以下なので O(log2N * log3N) となる。これは N<=2000　の場合に十分すぎるほど高速である。













